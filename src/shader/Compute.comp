#version 460
#extension GL_EXT_shader_image_load_formatted : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : require

// Work Group
layout (local_size_x = 8, local_size_y = 8) in;
// Descriptors
layout(set = 0, binding = 0, rgba16f) restrict uniform image2D image;
// Buffer reference raw data
layout(buffer_reference, std430) restrict buffer Vec4Buffer {
    vec4 data[];
};
// Push Constant
layout(push_constant, std430) restrict uniform PushConstants {
    vec4 camPosAndFov; // Last Float is Fov
    vec4 camDir;
    float runtime;
    uint dataCount;
    Vec4Buffer testData;
} pushConstants;

// Marching constants
const int MAX_STEPS = 1024 * 2;
const float MIN_DIST = 0.0001;
const float MAX_DIST = 500.0;
const float EPSILON = 0.001;

// SDFs
float sdSphere(vec3 pos, float radius) { 
    return length(pos) - radius; 
}

float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float sdCylinder(vec3 p, vec2 h) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - h;
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Operations
vec3 opRep(vec3 pos, vec3 spacing) { 
    return mod(pos + 0.5 * spacing, spacing) - 0.5 * spacing; 
}

// Repeating Scene
float map(vec3 pos) {
    vec3 repPos = opRep(pos, vec3(4.0, 4.0, 4.0));
    float sphere = sdSphere(repPos, 0.3);
    return sphere;
}

// Test Scene
// float map(vec3 pos) {
//     float sphere = sdSphere(pos, 0.5);
//     // 2. Box to the right, translated by (2, 0, 0)
//     float box = sdBox(pos - vec3(2.0, 0.0, 0.0), vec3(0.4));
//     // 3. Torus to the left, translated by (-2, 0, 0)
//     float torus = sdTorus(pos - vec3(-2.0, 0.0, 0.0), vec2(0.4, 0.1));
//     // Combine the distances using min() to get the closest surface
//     float result = min(sphere, box);
//     result = min(result, torus);
//     return result;
// }

// Functions
vec3 getNormal(vec3 pos) {
    vec3 n = vec3(
        map(pos + vec3(EPSILON, 0, 0)) - map(pos - vec3(EPSILON, 0, 0)),
        map(pos + vec3(0, EPSILON, 0)) - map(pos - vec3(0, EPSILON, 0)),
        map(pos + vec3(0, 0, EPSILON)) - map(pos - vec3(0, 0, EPSILON))
    );
    return normalize(n);
}

void main() {
    vec2 imageDims = vec2(imageSize(image));
    vec2 uv = (vec2(gl_GlobalInvocationID.xy) / imageDims) * 2.0 - 1.0;
    // Camera basis vectors
    vec3 camForward = normalize(pushConstants.camDir.xyz);
    vec3 camRight = normalize(cross(vec3(0, 1, 0), camForward));
    vec3 camUp = normalize(cross(camForward, camRight));

    float focalLength = 1.0 / tan(radians(pushConstants.camPosAndFov.w * 0.5));
    float aspectRatio = imageDims.x / imageDims.y;
    // Ray direction
    vec3 rayDir = normalize(uv.x * camRight * aspectRatio - uv.y * camUp + focalLength * camForward);
    
    float march = 0.0;
    bool hit = false;
    vec3 pos;
    
    for(int step = 0; step < MAX_STEPS; step++) {
        pos = pushConstants.camPosAndFov.xyz + rayDir * march;
        float closest = map(pos);
        if(closest < MIN_DIST) {
            hit = true;
            break;
        }
        march += closest;
        if(march > MAX_DIST) break;
    }
    
    if(hit) {
        vec3 normal = getNormal(pos);
        vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));
        float lighting = max(dot(normal, lightDir), 0.1);
        
        // Use test data for color variation
        float colorMod = 1.0;
        if(pushConstants.dataCount > 1) { // Safety check
            vec4 data = pushConstants.testData.data[1];
            colorMod = 0.5 + 0.5 * sin(length(data.xyz) * 3.14 + pushConstants.runtime);
        }
        
        vec3 surfaceColor = vec3(0.0, 0.8 * colorMod, 0.5);
        imageStore(image, ivec2(gl_GlobalInvocationID.xy), mix(vec4(surfaceColor * lighting, 1.0), vec4(0.0, 0.0, 0.0, 1.0), march / MAX_DIST));
    } else {
        imageStore(image, ivec2(gl_GlobalInvocationID.xy), vec4(0.0, 0.0, 0.0, 1.0));
    }
}