#version 460
#extension GL_EXT_shader_image_load_formatted : require
#extension GL_EXT_buffer_reference : require // Enable buffer references
#extension GL_EXT_scalar_block_layout : require // For better layout control

// Buffer reference type - direct GPU memory access
layout(buffer_reference, std430) buffer Vec4Buffer {
    vec4 data[];
};

// APPROACH A: Images/Textures/Samplers (using descriptor buffers)
layout(set = 0, binding = 0, rgba16f) uniform image2D image;

// APPROACH B: Buffer references - direct access via GPU addresses
layout(push_constant, std430) uniform PushConstants {
    float runtime;
    uint data_count;
    Vec4Buffer testData; // The 64-bit address
} pushConstants;

//size of a workgroup for compute
layout (local_size_x = 8, local_size_y = 8) in;

// View constants
const vec2 RESOLUTION = vec2(1600.0, 900.0);
const float ASPECT_RATIO = 16.0 / 9.0;
const float FOV_DEGREES = 120.0;
const float FOCAL_LENGTH = 1.0 / tan(radians(FOV_DEGREES * 0.5));
// Marching constants
const int MAX_STEPS = 1024 * 2;
const float MIN_DIST = 0.0001;
const float MAX_DIST = 500.0;
const float EPSILON = 0.001;
const vec3 CAM = vec3(0.0, 0.0, -5.0);

// SDFs
float sdSphere(vec3 pos, float radius) { return length(pos) - radius; }

// Operations
vec3 opRep(vec3 pos, vec3 spacing) { return mod(pos + 0.5 * spacing, spacing) - 0.5 * spacing; }

// Scene
float map(vec3 pos) {
    vec3 repPos = opRep(pos, vec3(4.0, 4.0, 4.0));
    float sphere = sdSphere(repPos, 0.3);
    return sphere;
}

// Functions
vec3 getNormal(vec3 pos) {
    vec3 n = vec3(
        map(pos + vec3(EPSILON, 0, 0)) - map(pos - vec3(EPSILON, 0, 0)),
        map(pos + vec3(0, EPSILON, 0)) - map(pos - vec3(0, EPSILON, 0)),
        map(pos + vec3(0, 0, EPSILON)) - map(pos - vec3(0, 0, EPSILON))
    );
    return normalize(n);
}

// MAIN PROGRAM
void main() {
    vec2 uv = (vec2(gl_GlobalInvocationID.xy) / vec2(imageSize(image))) * 2.0 - 1.0;
    vec3 rayDir = normalize(vec3(uv.x * ASPECT_RATIO, -uv.y, FOCAL_LENGTH));

    float march = 0.0;
    bool hit = false;
    vec3 pos;

    // Use test data for color variation
        float colorMod = 1.0;
        vec4 data = pushConstants.testData.data[1];
        colorMod = 0.5 + 0.5 * sin(length(data.xyz) * 3.14 + pushConstants.runtime);

    for(int step = 0; step < MAX_STEPS; step++) {
        pos = CAM + rayDir * march;
        float closest = map(pos);
        if(closest < MIN_DIST) {
            hit = true;
            break;
        }
        march += closest;
        if(march > MAX_DIST) break;
    }

    if(hit) {
        vec3 normal = getNormal(pos);
        vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));
        float lighting = max(dot(normal, lightDir), 0.1);
        
        // Use test data for color variation
        float colorMod = 1.0;
        vec4 data = pushConstants.testData.data[1];
        colorMod = 0.5 + 0.5 * sin(length(data.xyz) * 3.14 + pushConstants.runtime);
        
        vec3 surfaceColor = vec3(0.0, 0.8 * colorMod, 0.5);
        imageStore(image, ivec2(gl_GlobalInvocationID.xy), mix(vec4(surfaceColor * lighting, 1.0), vec4(0.0, 0.0, 0.0, 1.0), march / MAX_DIST));
    } else {
        imageStore(image, ivec2(gl_GlobalInvocationID.xy), vec4(0.0, 0.0, 0.0, 1.0));
    }
}